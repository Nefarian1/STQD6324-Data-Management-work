# -*- coding: utf-8 -*-
"""Assignment3

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1tJKLYw8vYTrGfmbiUvo5aec-kZlH7B-B

# STQD6324 Assignment 3 PANZHANGYU P136922
"""

pip install pyspark

from pyspark.sql import SparkSession
from sklearn.datasets import load_iris
import pandas as pd
from pyspark.ml.feature import VectorAssembler
from pyspark.ml.classification import RandomForestClassifier
from pyspark.ml import Pipeline
from pyspark.ml.tuning import CrossValidator, ParamGridBuilder
from pyspark.ml.evaluation import MulticlassClassificationEvaluator

# SparkSession
spark = SparkSession.builder.appName("IrisClassification").getOrCreate()

# 从sklearn加载Iris数据集 Loading the Iris dataset from sklearn
iris = load_iris()
iris_df = pd.DataFrame(data=iris.data, columns=iris.feature_names)
iris_df['label'] = iris.target

# 将pandas DataFrame转换为Spark      DataFrame Convert pandas DataFrame to Spark DataFrame
df = spark.createDataFrame(iris_df)

# 将数据集分为训练集和测试集 Split the dataset into training and testing sets
train_df, test_df = df.randomSplit([0.8, 0.2], seed=42)

# 将特征列组合成一个特征向量 Combine feature columns into a feature vector
assembler = VectorAssembler(inputCols=iris.feature_names, outputCol="features")
rf = RandomForestClassifier(labelCol="label", featuresCol="features")

# 创建Pipeline Creating a Pipeline
pipeline = Pipeline(stages=[assembler, rf])

# 创建参数网格 Creating a parameter grid
paramGrid = (ParamGridBuilder()
             .addGrid(rf.numTrees, [10, 20, 30])
             .addGrid(rf.maxDepth, [5, 10, 15])
             .build())

# 创建评估器 Creating an Evaluator
evaluator = MulticlassClassificationEvaluator(labelCol="label", predictionCol="prediction", metricName="accuracy")

# 创建交叉验证器 Creating a cross validator
crossval = CrossValidator(estimator=pipeline,
                          estimatorParamMaps=paramGrid,
                          evaluator=evaluator,
                          numFolds=3)

# 训练模型 Training the model
cvModel = crossval.fit(train_df)

# 在测试集上生成预测 Generate predictions on the test set
predictions = cvModel.transform(test_df)

# 打印预测数据的示例 Example of printing forecast data
predictions.select("features", "label", "prediction").show(5)

# 检查预测数据的schema Check the schema of the prediction data
predictions.printSchema()

# 评估模型性能 Evaluating Model Performance
accuracy = evaluator.evaluate(predictions)
print(f"Test Accuracy: {accuracy}")

# 计算其他评估指标 Calculating other evaluation metrics
evaluator.setMetricName("weightedPrecision")
precision = evaluator.evaluate(predictions)
print(f"Test Precision: {precision}")

evaluator.setMetricName("weightedRecall")
recall = evaluator.evaluate(predictions)
print(f"Test Recall: {recall}")

evaluator.setMetricName("f1")
f1 = evaluator.evaluate(predictions)
print(f"Test F1 Score: {f1}")

# 显示预测结果和实际标签 Display predictions and actual labels
predictions.select("features", "label", "prediction").show()

# 进行比较分析 Conduct comparative analysis
predictions.groupBy("label", "prediction").count().show()

import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.metrics import confusion_matrix

# 构建混淆矩阵 Constructing the confusion matrix
y_true = [0]*13 + [1]*6 + [2]*13
y_pred = [0]*13 + [1]*6 + [2]*12 + [1]

cm = confusion_matrix(y_true, y_pred)

# 可视化混淆矩阵 Visualizing the Confusion Matrix
plt.figure(figsize=(8, 6))
sns.heatmap(cm, annot=True, fmt='d', cmap='Blues', xticklabels=iris.target_names, yticklabels=iris.target_names)
plt.xlabel('Predicted')
plt.ylabel('Actual')
plt.title('Confusion Matrix')
plt.show()